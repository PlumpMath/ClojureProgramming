Chapter 5 (2/2) - Macros
===================

## Hygiene

- 매크로는 다른 코드에 embedded 되는 경우가 많은데, 이 때 매크로에서의 바인딩이 기존 코드의 바인딩과 잘못 엮여 버그를 일으키는 경우가 있으며, 이러한 버그는 원인을 파악하기 어려움.

```Clojure
(defmacro unhygienic 
    [& body]
    `(let [x :oops] 
        ~@body))
;=> #'user/unhygenic

(unhygienic (println "x:" x))
;=> CompilerException java.lang.RuntimeException: Can't let qualified name: user/x
```
- `let`은 식별되지 않은(unqualified) 심벌에 대한 바인딩을 수행하는데 여기서는 `user/x`에 대해 바인딩을 시도하므로 컴파일 에러(macro expansion 시)가 발생됨 
→ 이를 피하기 위해 quoting과 unquoting을 활용하여 다시 작성해보면,

```Clojure
(defmacro still-unhygienic 
    [& body]
      `(let [~'x :oops] ~@body))   ;; namespace 식별을 피할 수 있도록 변경
;=> #'user/still-unhygenic

(macroexpand-1 `(still-unhygienic
                  (println "x:" x))) 
;=> (clojure.core/let [x :oops]     ;; 확장결과에 user/x 가 아닌 x 가 포함됨
;=>     (clojure.core/println "x:" user/x))

(still-unhygienic (println "x:" x)) 
;=> x: :oops
```

그러나, 매크로의 로컬 범위 안과 밖에서 동일한 이름 `x`를 바인딩하고 있어 문제가 있다.

```Clojure
(let [x :this-is-important] 
    (still-unhygienic
        (println "x:" x))) 
; x: :oops
;; :this-is-important 가 출력되지 않음
```

